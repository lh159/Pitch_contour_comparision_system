# 录音功能云端部署说明

## 问题背景

原系统的录音功能完全基于浏览器的Web API（`navigator.mediaDevices.getUserMedia()` 和 `MediaRecorder`）在前端实现，这在电脑浏览器上工作良好，但在移动端或云服务器部署时会遇到以下问题：

1. **移动端兼容性问题**：部分移动浏览器对录音API支持不完善
2. **权限获取困难**：移动端获取麦克风权限更加严格
3. **云服务器部署限制**：纯前端录音无法在服务器端处理音频流

## 解决方案

实现了一个**录音API适配器**，支持两种录音模式：

### 1. 浏览器录音模式（Browser Mode）
- 适用于电脑浏览器环境
- 使用原有的`MediaRecorder` API
- 录音完成后通过现有的`/api/audio/upload`上传

### 2. 服务器录音模式（Server Mode）
- 适用于移动端和云服务器环境
- 通过新增的服务器API处理录音会话
- 支持实时音频数据流传输

## 新增文件

### 1. 录音API适配器 (`static/js/recording-api.js`)
```javascript
class RecordingAPIAdapter {
    // 自动检测录音支持情况
    async detectRecordingSupport()
    
    // 统一的录音接口
    async startRecording()
    async stopRecording()
    
    // 模式切换
    setMode(mode) // 'browser' 或 'server'
}
```

### 2. 测试脚本 (`test_recording_api.py`)
- 验证录音API功能
- 测试录音会话管理
- 文件上传功能测试

## 新增API端点

### 1. 开始录音会话
```http
POST /api/recording/start
Content-Type: application/json

{
    "session_id": "可选，不提供则自动生成"
}
```

**响应：**
```json
{
    "success": true,
    "session_id": "uuid-string",
    "message": "录音会话已开始"
}
```

### 2. 停止录音会话
```http
POST /api/recording/stop
Content-Type: application/json

{
    "session_id": "录音会话ID"
}
```

**响应：**
```json
{
    "success": true,
    "file_id": "生成的文件ID",
    "filename": "recording_xxx.wav",
    "duration": 3.45,
    "message": "录音已保存"
}
```

### 3. 上传录音数据块
```http
POST /api/recording/data
Content-Type: multipart/form-data

session_id: 录音会话ID
audio_chunk: 音频数据块文件
```

### 4. 查询录音状态
```http
GET /api/recording/status/{session_id}
```

**响应：**
```json
{
    "success": true,
    "is_recording": true,
    "duration": 2.5
}
```

## 代码修改

### 1. 后端修改 (`web_interface.py`)

#### 新增导入
```python
import io
import wave
import threading
import queue
```

#### 新增录音会话管理
```python
# 录音会话管理
recording_sessions = {}
recording_lock = threading.Lock()

class RecordingSession:
    """录音会话类"""
    def __init__(self, session_id):
        self.session_id = session_id
        self.is_recording = False
        self.audio_data = queue.Queue()
        # ... 其他属性
```

### 2. 前端修改 (`templates/recording.html`)

#### 引入新的录音适配器
```html
<!-- 录音API适配器 -->
<script src="{{ url_for('static', filename='js/recording-api.js') }}"></script>
```

#### 替换录音逻辑
```javascript
// 原来的 mediaRecorder 方式
let mediaRecorder = null;

// 新的适配器方式
let recordingAdapter = null;

// 初始化
recordingAdapter = new RecordingAPIAdapter();
await recordingAdapter.detectRecordingSupport();

// 录音操作
await recordingAdapter.startRecording();
await recordingAdapter.stopRecording();
```

## 工作原理

### 自动模式检测
1. 系统启动时检测浏览器录音支持情况
2. 尝试获取麦克风权限（不开始录音）
3. 检查`MediaRecorder`支持情况
4. 根据检测结果自动选择最佳模式

### 浏览器录音流程
```
用户点击录音 → 获取麦克风权限 → 创建MediaRecorder → 
开始录音 → 收集音频数据 → 停止录音 → 上传到服务器
```

### 服务器录音流程
```
用户点击录音 → 创建录音会话 → 前端采集音频 → 
实时发送到服务器 → 服务器缓存数据 → 停止录音 → 
合成WAV文件 → 返回文件信息
```

## 部署步骤

### 1. 上传修改的文件
```bash
# 上传到云服务器
scp web_interface.py root@your-server:/opt/pitch-compare/
scp static/js/recording-api.js root@your-server:/opt/pitch-compare/static/js/
scp templates/recording.html root@your-server:/opt/pitch-compare/templates/
```

### 2. 重启服务
```bash
# 在云服务器上
cd /opt/pitch-compare
python3 web_interface.py
```

### 3. 测试功能
```bash
# 运行测试脚本
python3 test_recording_api.py
```

## 兼容性说明

### 支持的环境
- ✅ 桌面浏览器（Chrome, Firefox, Safari, Edge）
- ✅ 移动浏览器（iOS Safari, Android Chrome）
- ✅ 云服务器部署
- ✅ 微信内置浏览器
- ✅ 其他移动应用内嵌浏览器

### 录音模式选择逻辑
```javascript
// 优先级：浏览器录音 > 服务器录音
if (浏览器支持 && 权限获取成功) {
    使用浏览器录音模式
} else {
    使用服务器录音模式
}
```

## 用户体验

### 桌面端
- 自动使用浏览器录音（高质量，低延迟）
- 显示提示："浏览器录音模式"

### 移动端
- 自动切换到服务器录音
- 显示提示："检测到移动端环境，将使用服务器录音模式"
- 录音过程显示："录音中 (服务器录音)..."

## 注意事项

### 1. 权限要求
- 浏览器录音需要麦克风权限
- HTTPS环境下录音功能更稳定

### 2. 性能考虑
- 服务器录音会占用更多服务器资源
- 建议设置录音时长限制

### 3. 错误处理
- 网络断开时的重连机制
- 录音会话超时清理
- 音频数据丢失的处理

### 4. 存储管理
- 定期清理临时录音文件
- 设置录音文件大小限制

## 测试验证

运行测试脚本验证功能：
```bash
python3 test_recording_api.py
```

测试内容包括：
- ✅ 录音会话创建
- ✅ 录音状态查询
- ✅ 录音会话停止
- ✅ 文件上传功能
- ✅ 错误处理机制

## 总结

通过实现录音API适配器，成功解决了移动端和云服务器部署时的录音功能问题。系统现在可以：

1. **自动适配**：根据环境自动选择最佳录音方式
2. **无缝切换**：用户无需手动选择录音模式
3. **跨平台兼容**：支持桌面和移动端所有主流浏览器
4. **云端友好**：完全支持云服务器部署

用户在任何环境下都能获得一致的录音体验，无需关心底层实现细节。
