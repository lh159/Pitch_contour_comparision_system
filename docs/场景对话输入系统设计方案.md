# 场景对话输入系统设计方案

## 项目概述

### 当前系统现状
- **现有功能**: 用户直接输入中文词汇，系统生成标准发音，用户跟读练习
- **局限性**: 缺乏语境，练习内容单一，用户参与度不高

### 升级目标
将系统升级为**智能场景对话练习平台**，用户输入场景描述，系统自动生成角色扮演对话，实现沉浸式中文发音练习。

## 核心功能设计

### 1. 场景输入与解析
- 用户输入场景描述（如：妈妈教导三年级小孩学习数学）
- 系统通过DeepSeek API智能解析场景
- 自动识别角色、背景、对话主题

### 2. 智能对话生成
- 基于场景生成多轮对话内容
- 明确区分用户角色（妈妈）和AI角色（小孩）
- 确保对话自然流畅，符合中文表达习惯

### 3. 交互式练习流程
- 用户朗读自己的台词
- 系统进行音高分析和评分
- AI播放对方角色台词
- 循环进行，形成完整对话

## 技术架构设计

### 1. 前端界面升级

#### 1.1 新增场景输入组件
```html
<!-- 场景输入区域 -->
<div class="scenario-input-section">
    <h4>🎭 场景对话模式</h4>
    <div class="input-group">
        <textarea class="form-control" id="scenarioInput" 
                  placeholder="请描述您想要练习的场景，例如：妈妈教导三年级小孩学习数学、朋友之间讨论周末计划、客服接待顾客咨询等..."
                  rows="3" maxlength="200"></textarea>
        <button class="btn btn-primary" id="generateScenarioBtn">
            <i class="fas fa-magic"></i> 生成场景对话
        </button>
    </div>
</div>
```

#### 1.2 对话展示组件
```html
<!-- 对话展示区域 -->
<div class="dialogue-container" id="dialogueContainer">
    <div class="dialogue-header">
        <h5 id="scenarioTitle">场景：妈妈教导小孩学习</h5>
        <div class="role-info">
            <span class="user-role">👩 您的角色：妈妈</span>
            <span class="ai-role">👶 AI角色：小孩</span>
        </div>
    </div>
    
    <div class="dialogue-content" id="dialogueContent">
        <!-- 动态生成对话内容 -->
    </div>
    
    <div class="dialogue-controls">
        <button class="btn btn-success" id="startDialogueBtn">开始对话</button>
        <button class="btn btn-warning" id="continueBtn" style="display:none;">继续对话</button>
        <button class="btn btn-info" id="regenerateBtn">重新生成</button>
    </div>
</div>
```

### 2. 后端API设计

#### 2.1 DeepSeek集成模块
```python
# deepseek_integration.py
import os
import requests
from typing import Dict, List
from config import Config

class DeepSeekDialogueGenerator:
    def __init__(self):
        self.api_key = Config.DEEPSEEK_API_KEY
        self.base_url = "https://api.deepseek.com/v1/chat/completions"
        
    def generate_scenario_dialogue(self, scenario_description: str, 
                                 dialogue_rounds: int = 6) -> Dict:
        """
        基于场景描述生成对话
        """
        system_prompt = """
        你是一个专业的中文对话生成助手。根据用户提供的场景描述，生成一个自然、生动的中文对话。
        
        要求：
        1. 对话应该包含6-8轮交互
        2. 明确区分两个角色的台词
        3. 语言自然流畅，符合中文表达习惯
        4. 每句台词长度适中（5-20个字）
        5. 内容积极正面，适合发音练习
        
        输出格式：JSON格式
        {
            "scenario_title": "场景标题",
            "user_role": "用户角色名称",
            "ai_role": "AI角色名称", 
            "dialogues": [
                {"speaker": "user", "text": "用户台词", "order": 1},
                {"speaker": "ai", "text": "AI台词", "order": 2},
                ...
            ]
        }
        """
        
        user_prompt = f"请基于以下场景生成对话：{scenario_description}"
        
        try:
            response = requests.post(
                self.base_url,
                headers={
                    "Authorization": f"Bearer {self.api_key}",
                    "Content-Type": "application/json"
                },
                json={
                    "model": "deepseek-chat",
                    "messages": [
                        {"role": "system", "content": system_prompt},
                        {"role": "user", "content": user_prompt}
                    ],
                    "temperature": 0.7,
                    "max_tokens": 1500
                }
            )
            
            if response.status_code == 200:
                result = response.json()
                dialogue_content = result['choices'][0]['message']['content']
                return self._parse_dialogue_response(dialogue_content)
            else:
                return {"success": False, "error": f"API调用失败: {response.status_code}"}
                
        except Exception as e:
            return {"success": False, "error": f"生成对话失败: {str(e)}"}
    
    def _parse_dialogue_response(self, content: str) -> Dict:
        """解析AI返回的对话内容"""
        try:
            import json
            dialogue_data = json.loads(content)
            return {"success": True, "data": dialogue_data}
        except:
            # 如果JSON解析失败，使用备用解析方法
            return self._fallback_parse(content)
```

#### 2.2 场景对话API端点
```python
# web_interface.py 新增路由

@app.route('/api/scenario/generate', methods=['POST'])
def generate_scenario_dialogue():
    """生成场景对话"""
    try:
        data = request.get_json()
        scenario = data.get('scenario', '').strip()
        
        if not scenario:
            return jsonify({
                'success': False,
                'error': '请输入场景描述'
            }), 400
        
        # 调用DeepSeek生成对话
        generator = DeepSeekDialogueGenerator()
        result = generator.generate_scenario_dialogue(scenario)
        
        if result.get('success'):
            # 保存对话会话
            session_id = str(uuid.uuid4())
            dialogue_sessions[session_id] = result['data']
            
            return jsonify({
                'success': True,
                'session_id': session_id,
                'dialogue_data': result['data']
            })
        else:
            return jsonify({
                'success': False,
                'error': result.get('error', '对话生成失败')
            }), 500
            
    except Exception as e:
        return jsonify({
            'success': False,
            'error': f'服务器错误: {str(e)}'
        }), 500

@app.route('/api/scenario/next', methods=['POST'])
def get_next_dialogue():
    """获取下一句对话"""
    try:
        data = request.get_json()
        session_id = data.get('session_id')
        current_order = data.get('current_order', 0)
        
        if session_id not in dialogue_sessions:
            return jsonify({
                'success': False,
                'error': '对话会话不存在'
            }), 404
        
        dialogue_data = dialogue_sessions[session_id]
        next_dialogue = None
        
        for dialogue in dialogue_data['dialogues']:
            if dialogue['order'] == current_order + 1:
                next_dialogue = dialogue
                break
        
        if next_dialogue:
            # 如果是AI角色台词，生成TTS音频
            if next_dialogue['speaker'] == 'ai':
                file_id = str(uuid.uuid4())
                filename = f"ai_dialogue_{file_id}.wav"
                output_path = os.path.join(Config.TEMP_FOLDER, filename)
                
                success = tts_manager.generate_standard_audio(
                    next_dialogue['text'], output_path
                )
                
                if success:
                    next_dialogue['audio_url'] = url_for('serve_temp_file', filename=filename)
            
            return jsonify({
                'success': True,
                'dialogue': next_dialogue,
                'is_complete': current_order + 1 >= len(dialogue_data['dialogues'])
            })
        else:
            return jsonify({
                'success': True,
                'dialogue': None,
                'is_complete': True
            })
            
    except Exception as e:
        return jsonify({
            'success': False,
            'error': f'获取对话失败: {str(e)}'
        }), 500
```

### 3. 前端JavaScript逻辑

#### 3.1 场景对话管理器
```javascript
// scenario-dialogue.js
class ScenarioDialogueManager {
    constructor() {
        this.currentSession = null;
        this.currentOrder = 0;
        this.dialogueData = null;
        this.isPlaying = false;
        
        this.initializeEventListeners();
    }
    
    initializeEventListeners() {
        document.getElementById('generateScenarioBtn')
            .addEventListener('click', () => this.generateScenario());
        
        document.getElementById('startDialogueBtn')
            .addEventListener('click', () => this.startDialogue());
            
        document.getElementById('continueBtn')
            .addEventListener('click', () => this.continueDialogue());
    }
    
    async generateScenario() {
        const scenario = document.getElementById('scenarioInput').value.trim();
        
        if (!scenario) {
            showAlert('请输入场景描述', 'warning');
            return;
        }
        
        const generateBtn = document.getElementById('generateScenarioBtn');
        generateBtn.disabled = true;
        generateBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> 生成中...';
        
        try {
            const response = await fetch('/api/scenario/generate', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ scenario: scenario })
            });
            
            const data = await response.json();
            
            if (data.success) {
                this.currentSession = data.session_id;
                this.dialogueData = data.dialogue_data;
                this.currentOrder = 0;
                
                this.displayDialogue();
                showAlert('场景对话生成成功！', 'success');
            } else {
                showAlert(`生成失败: ${data.error}`, 'danger');
            }
        } catch (error) {
            showAlert(`网络错误: ${error.message}`, 'danger');
        } finally {
            generateBtn.disabled = false;
            generateBtn.innerHTML = '<i class="fas fa-magic"></i> 生成场景对话';
        }
    }
    
    displayDialogue() {
        const container = document.getElementById('dialogueContainer');
        const titleEl = document.getElementById('scenarioTitle');
        const contentEl = document.getElementById('dialogueContent');
        
        titleEl.textContent = `场景：${this.dialogueData.scenario_title}`;
        
        // 显示角色信息
        document.querySelector('.user-role').textContent = 
            `👤 您的角色：${this.dialogueData.user_role}`;
        document.querySelector('.ai-role').textContent = 
            `🤖 AI角色：${this.dialogueData.ai_role}`;
        
        // 生成对话列表
        contentEl.innerHTML = '';
        this.dialogueData.dialogues.forEach((dialogue, index) => {
            const dialogueItem = document.createElement('div');
            dialogueItem.className = `dialogue-item ${dialogue.speaker}-dialogue`;
            dialogueItem.innerHTML = `
                <div class="dialogue-speaker">${dialogue.speaker === 'user' ? this.dialogueData.user_role : this.dialogueData.ai_role}</div>
                <div class="dialogue-text">${dialogue.text}</div>
                <div class="dialogue-status" id="status-${dialogue.order}">
                    ${dialogue.speaker === 'user' ? '待练习' : '待播放'}
                </div>
            `;
            contentEl.appendChild(dialogueItem);
        });
        
        container.style.display = 'block';
        document.getElementById('startDialogueBtn').style.display = 'inline-block';
    }
    
    async startDialogue() {
        this.currentOrder = 1;
        await this.processCurrentDialogue();
    }
    
    async processCurrentDialogue() {
        const currentDialogue = this.dialogueData.dialogues.find(
            d => d.order === this.currentOrder
        );
        
        if (!currentDialogue) {
            showAlert('对话已完成！', 'success');
            return;
        }
        
        const statusEl = document.getElementById(`status-${this.currentOrder}`);
        
        if (currentDialogue.speaker === 'user') {
            // 用户台词 - 进入录音模式
            statusEl.textContent = '请朗读';
            statusEl.className = 'dialogue-status active';
            
            // 设置当前文本并启动录音功能
            document.getElementById('textInput').value = currentDialogue.text;
            await this.startUserRecording(currentDialogue.text);
            
        } else {
            // AI台词 - 播放音频
            statusEl.textContent = '播放中';
            statusEl.className = 'dialogue-status playing';
            
            await this.playAIDialogue(currentDialogue);
        }
    }
    
    async startUserRecording(text) {
        // 集成现有的录音功能
        currentText = text;
        
        // 生成标准发音
        await generateStandardAudio();
        
        // 显示录音界面
        document.getElementById('standardAudioCard').style.display = 'block';
        document.getElementById('recordingCard').style.display = 'block';
        
        // 自动开始录音（可选）
        showAlert('请朗读您的台词，完成后点击"继续对话"', 'info');
        document.getElementById('continueBtn').style.display = 'inline-block';
    }
    
    async playAIDialogue(dialogue) {
        try {
            // 获取AI对话音频
            const response = await fetch('/api/scenario/next', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    session_id: this.currentSession,
                    current_order: this.currentOrder - 1
                })
            });
            
            const data = await response.json();
            
            if (data.success && data.dialogue && data.dialogue.audio_url) {
                const audio = new Audio(data.dialogue.audio_url);
                
                audio.onplay = () => {
                    this.isPlaying = true;
                };
                
                audio.onended = () => {
                    this.isPlaying = false;
                    const statusEl = document.getElementById(`status-${this.currentOrder}`);
                    statusEl.textContent = '已完成';
                    statusEl.className = 'dialogue-status completed';
                    
                    // 自动进入下一轮对话
                    setTimeout(() => {
                        this.currentOrder++;
                        this.processCurrentDialogue();
                    }, 1000);
                };
                
                audio.play();
            }
        } catch (error) {
            showAlert(`播放失败: ${error.message}`, 'danger');
        }
    }
    
    async continueDialogue() {
        // 完成当前用户对话，进入下一轮
        const statusEl = document.getElementById(`status-${this.currentOrder}`);
        statusEl.textContent = '已完成';
        statusEl.className = 'dialogue-status completed';
        
        document.getElementById('continueBtn').style.display = 'none';
        
        this.currentOrder++;
        await this.processCurrentDialogue();
    }
}

// 初始化场景对话管理器
let scenarioManager;
document.addEventListener('DOMContentLoaded', function() {
    scenarioManager = new ScenarioDialogueManager();
});
```

### 4. 配置文件更新

#### 4.1 环境变量配置
```bash
# .env 文件新增
DEEPSEEK_API_KEY=sk-c48010af3fad435f94e48b613916b1b2
```

#### 4.2 Config.py 更新
```python
# config.py 新增配置项
class Config:
    # ... 现有配置 ...
    
    # DeepSeek API配置
    DEEPSEEK_API_KEY = os.getenv('DEEPSEEK_API_KEY', '')
    
    # 场景对话配置
    MAX_SCENARIO_LENGTH = 200  # 场景描述最大长度
    DEFAULT_DIALOGUE_ROUNDS = 6  # 默认对话轮数
    DIALOGUE_SESSION_TIMEOUT = 3600  # 对话会话超时时间（秒）
```

## 用户体验流程

### 1. 场景输入阶段
1. 用户在新的场景输入框中描述想要练习的场景
2. 点击"生成场景对话"按钮
3. 系统调用DeepSeek API生成对话内容
4. 展示完整的对话脚本和角色分配

### 2. 互动练习阶段
1. 用户点击"开始对话"
2. 系统显示用户的第一句台词
3. 用户朗读台词，系统进行音高分析
4. 用户点击"继续对话"
5. 系统播放AI角色的回应
6. 循环进行直到对话结束

### 3. 学习反馈阶段
1. 每句台词都有音高分析和评分
2. 对话结束后提供整体表现报告
3. 可以重新练习或生成新场景

## 技术实现优势

### 1. 智能化程度高
- 基于先进的AI模型生成自然对话
- 自动适应不同场景和角色设定
- 内容丰富多样，避免重复练习

### 2. 交互体验优秀
- 沉浸式角色扮演体验
- 实时音频反馈和指导
- 循序渐进的学习过程

### 3. 技术架构合理
- 模块化设计，易于维护和扩展
- 充分利用现有的音高分析功能
- API设计清晰，支持多种扩展

## 预期效果

### 1. 用户参与度提升
- 从单一词汇练习升级为情景对话
- 增加学习的趣味性和实用性
- 提供更真实的语言使用场景

### 2. 学习效果改善
- 在语境中学习发音，更加自然
- 通过角色扮演增强记忆效果
- 培养实际对话能力

### 3. 系统价值提升
- 从工具型产品升级为平台型产品
- 增加用户粘性和使用频率
- 为后续功能扩展奠定基础

## 开发计划

### Phase 1: 基础架构（1-2周）
- [ ] DeepSeek API集成
- [ ] 基础对话生成功能
- [ ] 简单的前端界面

### Phase 2: 核心功能（2-3周）
- [ ] 完整的对话管理系统
- [ ] 音频播放和录音集成
- [ ] 用户体验优化

### Phase 3: 高级功能（1-2周）
- [ ] 对话质量优化
- [ ] 多场景模板支持
- [ ] 性能优化和错误处理

### Phase 4: 测试和发布（1周）
- [ ] 全面测试
- [ ] 文档完善
- [ ] 用户反馈收集

## 风险评估与应对

### 1. API依赖风险
- **风险**: DeepSeek API可能不稳定或限流
- **应对**: 实现备用对话生成方案，缓存常用场景

### 2. 对话质量风险
- **风险**: AI生成的对话可能不够自然
- **应对**: 优化prompt设计，增加人工审核机制

### 3. 用户接受度风险
- **风险**: 用户可能不习惯新的交互方式
- **应对**: 提供详细的使用指南，保留原有功能

## 总结

这个场景对话输入系统将显著提升用户的学习体验，从简单的词汇练习升级为沉浸式的情景对话练习。通过智能AI生成个性化的对话内容，结合现有的音高分析技术，为用户提供更加丰富和实用的中文发音学习平台。

该方案充分利用了现有系统的技术积累，在保持原有功能的基础上，增加了创新的场景对话功能，是一个技术可行、用户友好的升级方案。
