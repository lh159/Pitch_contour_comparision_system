# 听觉反馈系统设计文档

## 一、系统概述

### 1.1 目标用户
听障人士，用于帮助他们检测和提高听力理解能力。

### 1.2 核心功能
1. 播放系统生成的场景对话音频（逐句播放）
2. 用户听完后输入听到的文字内容
3. 系统进行文字智能比对，高亮标记错误
4. 全对时给予正向激励反馈
5. 自动进入下一句，完成完整场景对话

### 1.3 技术亮点
- 复用现有的场景对话生成功能
- 智能文字比对算法（支持同音字、近似字识别）
- 可视化错误标记
- 游戏化激励机制
- 进度统计和分析

---

## 二、系统架构设计

### 2.1 整体架构
```
前端UI层
  ├── 场景选择页面
  ├── 听力训练页面（核心）
  ├── 结果统计页面
  
后端API层
  ├── 场景对话生成API（已有）
  ├── 文字比对API（新增）
  ├── 进度管理API（新增）
  ├── 统计分析API（新增）
  
数据层
  ├── 训练会话存储
  ├── 用户答题记录
  ├── 统计数据存储
```

### 2.2 页面流程图
```
Home页 → 听觉反馈入口
  ↓
场景选择/生成
  ↓
听力训练主界面
  ├── 播放当前句音频
  ├── 用户输入文字
  ├── 提交比对
  ├── 显示结果（错误标记/激励）
  ├── 下一句
  ↓
训练完成报告
  ├── 正确率统计
  ├── 错误类型分析
  ├── 建议与鼓励
```

---

## 三、详细构建步骤

### 步骤1: 前端UI设计与实现

#### 1.1 在home.html添加听觉反馈入口
**文件**: `templates/home.html`

**位置**: 在"选择练习模式"区域添加第三个选项

**代码实现**:
```html
<div class="col-md-4">
    <div class="form-check">
        <input class="form-check-input" type="radio" name="practiceMode" id="feedbackMode" value="feedback">
        <label class="form-check-label fw-bold" for="feedbackMode">
            <i class="fas fa-headphones me-2 text-info"></i>听觉反馈模式 <span class="badge bg-info ms-1">辅助功能</span>
        </label>
        <div class="form-text text-muted ms-4">帮助听障人士检测听力理解能力</div>
    </div>
</div>
```

#### 1.2 创建听觉反馈训练页面
**文件**: `templates/hearing_feedback.html`

**核心组件**:
1. **场景信息卡片**
   - 显示场景标题和描述
   - 显示当前进度（第X句/共Y句）

2. **音频播放区域**
   - 大号播放按钮
   - 可重复播放当前句
   - 播放次数统计
   - 播放速度调节（0.75x, 1x, 1.25x）

3. **文字输入区域**
   - 大号文本输入框
   - 支持实时字数统计
   - 清空按钮
   - 提交按钮

4. **结果展示区域**
   - 原文展示
   - 用户输入展示（错误高亮）
   - 正确率显示
   - 激励动画（全对时）

5. **操作按钮**
   - 重新听一遍
   - 下一句
   - 查看统计
   - 退出训练

**页面布局结构**:
```html
<div class="feedback-container">
    <!-- 进度条 -->
    <div class="progress-section">
        <div class="progress-bar"></div>
        <div class="progress-text">第 1 / 10 句</div>
    </div>
    
    <!-- 音频播放卡片 -->
    <div class="audio-card">
        <button class="play-btn">▶️ 播放音频</button>
        <div class="play-controls">
            <span>播放次数: 0</span>
            <select class="speed-control">
                <option value="0.75">0.75x</option>
                <option value="1" selected>1x</option>
                <option value="1.25">1.25x</option>
            </select>
        </div>
    </div>
    
    <!-- 输入区域 -->
    <div class="input-card">
        <textarea placeholder="请输入你听到的内容..."></textarea>
        <div class="input-actions">
            <button class="clear-btn">清空</button>
            <button class="submit-btn">提交</button>
        </div>
    </div>
    
    <!-- 结果展示区域（初始隐藏）-->
    <div class="result-card" style="display:none;">
        <div class="original-text">
            <h5>原文：</h5>
            <p>这是标准文本内容</p>
        </div>
        <div class="user-input">
            <h5>您的输入：</h5>
            <p>这是用户输入<span class="error">内荣</span></p>
        </div>
        <div class="score">
            <h3>准确率：<span class="score-value">90%</span></h3>
        </div>
        <div class="feedback-message">
            <!-- 激励信息 -->
        </div>
    </div>
    
    <!-- 操作按钮 -->
    <div class="action-buttons">
        <button class="replay-btn">🔄 重新听</button>
        <button class="next-btn">➡️ 下一句</button>
        <button class="stats-btn">📊 查看统计</button>
    </div>
</div>
```

#### 1.3 创建JavaScript交互逻辑
**文件**: `static/js/hearing-feedback.js`

**核心功能实现**:

```javascript
class HearingFeedbackTrainer {
    constructor() {
        this.sessionId = null;
        this.dialogueData = null;
        this.currentIndex = 0;
        this.currentAudio = null;
        this.playCount = 0;
        this.records = []; // 记录每句的答题情况
        
        this.initElements();
        this.bindEvents();
    }
    
    // 初始化DOM元素
    initElements() {
        this.playBtn = document.querySelector('.play-btn');
        this.inputArea = document.querySelector('textarea');
        this.submitBtn = document.querySelector('.submit-btn');
        this.resultCard = document.querySelector('.result-card');
        // ... 其他元素
    }
    
    // 绑定事件
    bindEvents() {
        this.playBtn.addEventListener('click', () => this.playAudio());
        this.submitBtn.addEventListener('click', () => this.submitAnswer());
        // ... 其他事件
    }
    
    // 加载场景对话
    async loadDialogue(sessionId) {
        const response = await fetch(`/api/scenario/session/${sessionId}`);
        const data = await response.json();
        if (data.success) {
            this.dialogueData = data.session_data.dialogue_data;
            this.loadSentence(0);
        }
    }
    
    // 加载当前句子
    loadSentence(index) {
        const sentence = this.dialogueData.dialogues[index];
        // 更新UI，准备播放
        this.currentAudio = new Audio(sentence.audio_url);
        this.playCount = 0;
        this.updateProgress();
    }
    
    // 播放音频
    playAudio() {
        if (this.currentAudio) {
            this.currentAudio.play();
            this.playCount++;
            this.updatePlayCount();
        }
    }
    
    // 提交答案
    async submitAnswer() {
        const userInput = this.inputArea.value.trim();
        const originalText = this.dialogueData.dialogues[this.currentIndex].text;
        
        // 调用文字比对API
        const response = await fetch('/api/feedback/compare', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({
                original: originalText,
                user_input: userInput,
                session_id: this.sessionId,
                sentence_index: this.currentIndex
            })
        });
        
        const result = await response.json();
        this.showResult(result);
    }
    
    // 显示比对结果
    showResult(result) {
        this.resultCard.style.display = 'block';
        
        // 显示原文和用户输入（带错误标记）
        this.showOriginalText(result.original);
        this.showUserInput(result.user_input_marked);
        
        // 显示准确率
        this.showAccuracy(result.accuracy);
        
        // 显示激励信息
        if (result.accuracy === 100) {
            this.showPerfectFeedback();
        } else {
            this.showEncouragementFeedback(result.accuracy);
        }
        
        // 保存记录
        this.records.push({
            index: this.currentIndex,
            original: result.original,
            user_input: result.user_input,
            accuracy: result.accuracy,
            play_count: this.playCount
        });
    }
    
    // 下一句
    nextSentence() {
        this.currentIndex++;
        if (this.currentIndex < this.dialogueData.dialogues.length) {
            this.loadSentence(this.currentIndex);
            this.resetUI();
        } else {
            this.showFinalReport();
        }
    }
    
    // 显示最终报告
    showFinalReport() {
        // 跳转到统计页面
        window.location.href = '/feedback-report?session=' + this.sessionId;
    }
}

// 初始化
const trainer = new HearingFeedbackTrainer();
```

#### 1.4 CSS样式设计
**文件**: `static/css/hearing-feedback.css`

**核心样式**:
- 大号按钮和文字（适合视力辅助）
- 高对比度配色方案
- 清晰的视觉反馈（错误用红色，正确用绿色）
- 流畅的动画效果
- 响应式布局（支持移动端）

---

### 步骤2: 后端API开发

#### 2.1 文字比对算法实现
**文件**: `text_comparator.py`

**核心算法**:

```python
# -*- coding: utf-8 -*-
"""
文字比对模块
用于听觉反馈系统的文字智能比对
"""

import difflib
from typing import Dict, List, Tuple
import re

class TextComparator:
    """文字比对器"""
    
    def __init__(self):
        # 同音字映射表
        self.homophone_map = self._load_homophone_map()
        
        # 形近字映射表
        self.similar_char_map = self._load_similar_char_map()
    
    def compare(self, original: str, user_input: str) -> Dict:
        """
        智能比对两段文字
        
        Args:
            original: 原始文本
            user_input: 用户输入
            
        Returns:
            Dict: 比对结果
        """
        # 1. 预处理
        original_clean = self._preprocess(original)
        user_input_clean = self._preprocess(user_input)
        
        # 2. 计算编辑距离
        distance = self._edit_distance(original_clean, user_input_clean)
        
        # 3. 字符级别对比
        char_diff = self._char_level_diff(original_clean, user_input_clean)
        
        # 4. 标记错误
        marked_text = self._mark_errors(user_input, char_diff)
        
        # 5. 计算准确率
        accuracy = self._calculate_accuracy(original_clean, user_input_clean, distance)
        
        # 6. 错误分析
        error_analysis = self._analyze_errors(char_diff)
        
        return {
            'original': original,
            'user_input': user_input,
            'user_input_marked': marked_text,
            'accuracy': accuracy,
            'error_count': error_analysis['total_errors'],
            'error_types': error_analysis['error_types'],
            'suggestions': self._generate_suggestions(error_analysis)
        }
    
    def _preprocess(self, text: str) -> str:
        """预处理文本"""
        # 去除空格、标点符号
        text = re.sub(r'[^\w]', '', text)
        return text.strip()
    
    def _edit_distance(self, s1: str, s2: str) -> int:
        """计算编辑距离（Levenshtein距离）"""
        m, n = len(s1), len(s2)
        dp = [[0] * (n + 1) for _ in range(m + 1)]
        
        for i in range(m + 1):
            dp[i][0] = i
        for j in range(n + 1):
            dp[0][j] = j
        
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                if s1[i-1] == s2[j-1]:
                    dp[i][j] = dp[i-1][j-1]
                else:
                    dp[i][j] = min(
                        dp[i-1][j] + 1,    # 删除
                        dp[i][j-1] + 1,    # 插入
                        dp[i-1][j-1] + 1   # 替换
                    )
        
        return dp[m][n]
    
    def _char_level_diff(self, s1: str, s2: str) -> List[Tuple]:
        """
        字符级别差异比对
        返回格式: [('equal', 'a'), ('replace', 'b', 'c'), ('delete', 'd')]
        """
        matcher = difflib.SequenceMatcher(None, s1, s2)
        diffs = []
        
        for tag, i1, i2, j1, j2 in matcher.get_opcodes():
            if tag == 'equal':
                for k in range(i1, i2):
                    diffs.append(('equal', s1[k]))
            elif tag == 'replace':
                # 检查是否是同音字或形近字
                if self._is_homophone(s1[i1:i2], s2[j1:j2]):
                    diffs.append(('homophone', s1[i1:i2], s2[j1:j2]))
                elif self._is_similar_char(s1[i1:i2], s2[j1:j2]):
                    diffs.append(('similar', s1[i1:i2], s2[j1:j2]))
                else:
                    diffs.append(('replace', s1[i1:i2], s2[j1:j2]))
            elif tag == 'delete':
                diffs.append(('delete', s1[i1:i2]))
            elif tag == 'insert':
                diffs.append(('insert', s2[j1:j2]))
        
        return diffs
    
    def _mark_errors(self, user_input: str, char_diff: List) -> str:
        """标记错误的HTML"""
        marked = []
        
        for item in char_diff:
            if item[0] == 'equal':
                marked.append(item[1])
            elif item[0] == 'replace':
                marked.append(f'<span class="error-replace" title="应为：{item[1]}">{item[2]}</span>')
            elif item[0] == 'homophone':
                marked.append(f'<span class="error-homophone" title="同音字，应为：{item[1]}">{item[2]}</span>')
            elif item[0] == 'similar':
                marked.append(f'<span class="error-similar" title="形近字，应为：{item[1]}">{item[2]}</span>')
            elif item[0] == 'delete':
                marked.append(f'<span class="error-missing" title="缺少：{item[1]}">_</span>')
            elif item[0] == 'insert':
                marked.append(f'<span class="error-extra">{item[1]}</span>')
        
        return ''.join(marked)
    
    def _calculate_accuracy(self, original: str, user_input: str, distance: int) -> float:
        """计算准确率"""
        max_len = max(len(original), len(user_input))
        if max_len == 0:
            return 100.0
        
        accuracy = (1 - distance / max_len) * 100
        return round(accuracy, 2)
    
    def _analyze_errors(self, char_diff: List) -> Dict:
        """错误分析"""
        error_types = {
            'replace': 0,
            'homophone': 0,
            'similar': 0,
            'missing': 0,
            'extra': 0
        }
        
        for item in char_diff:
            if item[0] in error_types:
                error_types[item[0]] += 1
        
        total_errors = sum(error_types.values())
        
        return {
            'total_errors': total_errors,
            'error_types': error_types
        }
    
    def _generate_suggestions(self, error_analysis: Dict) -> List[str]:
        """生成改进建议"""
        suggestions = []
        error_types = error_analysis['error_types']
        
        if error_types['homophone'] > 2:
            suggestions.append('注意区分同音字，可以结合上下文理解')
        if error_types['similar'] > 2:
            suggestions.append('注意形近字的区别，建议加强字形辨识练习')
        if error_types['missing'] > 2:
            suggestions.append('有些字可能听漏了，可以尝试降低播放速度')
        if error_types['extra'] > 2:
            suggestions.append('有些字可能听多了，注意音频的完整性')
        
        if not suggestions:
            suggestions.append('继续保持，你做得很好！')
        
        return suggestions
    
    def _is_homophone(self, char1: str, char2: str) -> bool:
        """判断是否是同音字"""
        # 这里需要实现同音字判断逻辑
        # 可以使用pypinyin库
        return False
    
    def _is_similar_char(self, char1: str, char2: str) -> bool:
        """判断是否是形近字"""
        # 实现形近字判断逻辑
        return False
    
    def _load_homophone_map(self) -> Dict:
        """加载同音字映射表"""
        # 可以从文件或数据库加载
        return {}
    
    def _load_similar_char_map(self) -> Dict:
        """加载形近字映射表"""
        return {}
```

#### 2.2 添加API端点
**文件**: `web_interface.py`

**新增路由**:

```python
# 导入文字比对模块
from text_comparator import TextComparator

# 初始化文字比对器
text_comparator = TextComparator()

# 听觉反馈会话存储
feedback_sessions = {}

@app.route('/hearing-feedback')
def hearing_feedback_page():
    """听觉反馈训练页面"""
    return render_template('hearing_feedback.html')

@app.route('/api/feedback/start', methods=['POST'])
def start_feedback_session():
    """开始听觉反馈训练会话"""
    try:
        data = request.get_json()
        scenario = data.get('scenario', '').strip()
        
        # 生成场景对话
        generator = get_deepseek_generator()
        result = generator.generate_scenario_dialogue(scenario, Config.DEFAULT_DIALOGUE_ROUNDS)
        
        if result.get('success'):
            # 创建训练会话
            session_id = str(uuid.uuid4())
            feedback_sessions[session_id] = {
                'dialogue_data': result['data'],
                'scenario': scenario,
                'start_time': time.time(),
                'records': [],
                'current_index': 0
            }
            
            return jsonify({
                'success': True,
                'session_id': session_id,
                'dialogue_data': result['data']
            })
        else:
            return jsonify({
                'success': False,
                'error': '场景对话生成失败'
            }), 500
            
    except Exception as e:
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500

@app.route('/api/feedback/compare', methods=['POST'])
def compare_feedback_text():
    """文字比对API"""
    try:
        data = request.get_json()
        original = data.get('original', '')
        user_input = data.get('user_input', '')
        session_id = data.get('session_id')
        sentence_index = data.get('sentence_index', 0)
        
        # 进行文字比对
        result = text_comparator.compare(original, user_input)
        
        # 保存到会话记录
        if session_id in feedback_sessions:
            feedback_sessions[session_id]['records'].append({
                'index': sentence_index,
                'original': original,
                'user_input': user_input,
                'accuracy': result['accuracy'],
                'timestamp': time.time()
            })
        
        return jsonify({
            'success': True,
            **result
        })
        
    except Exception as e:
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500

@app.route('/api/feedback/stats/<session_id>', methods=['GET'])
def get_feedback_stats(session_id):
    """获取训练统计"""
    try:
        if session_id not in feedback_sessions:
            return jsonify({
                'success': False,
                'error': '会话不存在'
            }), 404
        
        session = feedback_sessions[session_id]
        records = session['records']
        
        # 计算统计数据
        total_sentences = len(records)
        total_accuracy = sum(r['accuracy'] for r in records)
        avg_accuracy = total_accuracy / total_sentences if total_sentences > 0 else 0
        
        perfect_count = sum(1 for r in records if r['accuracy'] == 100)
        
        stats = {
            'total_sentences': total_sentences,
            'completed_sentences': len(records),
            'average_accuracy': round(avg_accuracy, 2),
            'perfect_count': perfect_count,
            'perfect_rate': round(perfect_count / total_sentences * 100, 2) if total_sentences > 0 else 0,
            'training_duration': time.time() - session['start_time'],
            'records': records
        }
        
        return jsonify({
            'success': True,
            'stats': stats
        })
        
    except Exception as e:
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500

@app.route('/feedback-report')
def feedback_report_page():
    """听觉反馈训练报告页面"""
    return render_template('feedback_report.html')
```

---

### 步骤3: 数据库设计（可选）

如果需要持久化存储用户训练数据，可以设计以下数据表：

#### 3.1 训练会话表 (feedback_sessions)
```sql
CREATE TABLE feedback_sessions (
    id VARCHAR(36) PRIMARY KEY,
    user_id VARCHAR(36),
    scenario TEXT,
    start_time TIMESTAMP,
    end_time TIMESTAMP,
    total_sentences INT,
    average_accuracy FLOAT,
    status VARCHAR(20)  -- 'in_progress', 'completed', 'abandoned'
);
```

#### 3.2 答题记录表 (feedback_records)
```sql
CREATE TABLE feedback_records (
    id INT AUTO_INCREMENT PRIMARY KEY,
    session_id VARCHAR(36),
    sentence_index INT,
    original_text TEXT,
    user_input TEXT,
    accuracy FLOAT,
    play_count INT,
    timestamp TIMESTAMP,
    FOREIGN KEY (session_id) REFERENCES feedback_sessions(id)
);
```

#### 3.3 错误统计表 (feedback_errors)
```sql
CREATE TABLE feedback_errors (
    id INT AUTO_INCREMENT PRIMARY KEY,
    record_id INT,
    error_type VARCHAR(20),  -- 'replace', 'homophone', 'similar', 'missing', 'extra'
    error_position INT,
    expected_char VARCHAR(10),
    actual_char VARCHAR(10),
    FOREIGN KEY (record_id) REFERENCES feedback_records(id)
);
```

---

### 步骤4: 激励系统设计

#### 4.1 即时反馈
- **100%准确**: 
  - 显示🎉庆祝动画
  - 文字："太棒了！完全正确！"
  - 音效：成功音效

- **90-99%准确**:
  - 显示👍点赞图标
  - 文字："非常好！只有小瑕疵"
  - 显示具体错误

- **70-89%准确**:
  - 显示💪加油图标
  - 文字："不错！继续加油"
  - 建议重听或降低速度

- **<70%准确**:
  - 显示🤔思考图标
  - 文字："没关系，再试一次吧"
  - 建议降低速度、多听几遍

#### 4.2 成就系统
```javascript
const achievements = {
    'first_perfect': {
        name: '首次满分',
        icon: '🌟',
        condition: (stats) => stats.perfect_count >= 1
    },
    'five_perfect': {
        name: '五连击',
        icon: '🔥',
        condition: (stats) => stats.consecutive_perfect >= 5
    },
    'accuracy_90': {
        name: '优等生',
        icon: '🎓',
        condition: (stats) => stats.average_accuracy >= 90
    },
    'persistent': {
        name: '坚持不懈',
        icon: '💪',
        condition: (stats) => stats.total_sentences >= 50
    }
};
```

---

### 步骤5: 用户体验优化

#### 5.1 无障碍设计
- 大号按钮（最小 60x60px）
- 高对比度配色（WCAG AA标准）
- 支持键盘操作（空格播放、回车提交）
- 语音提示（TTS朗读结果）

#### 5.2 个性化设置
```javascript
{
    'playbackSpeed': [0.5, 0.75, 1.0, 1.25],  // 播放速度
    'fontSize': ['small', 'medium', 'large'],  // 字体大小
    'theme': ['light', 'dark', 'high-contrast'],  // 主题
    'autoNext': true,  // 自动进入下一句
    'showHints': true,  // 显示提示
    'strictMode': false  // 严格模式（同音字也算错）
}
```

#### 5.3 渐进式难度
- **简单**: 短句（5-10字），慢速播放
- **中等**: 中等长度（10-20字），正常速度
- **困难**: 长句（20-30字），快速播放
- **专家**: 复杂场景，有背景音

---

### 步骤6: 测试与部署

#### 6.1 功能测试清单
- [ ] 场景对话生成正常
- [ ] 音频播放流畅
- [ ] 文字输入无延迟
- [ ] 比对算法准确
- [ ] 错误标记清晰
- [ ] 激励系统触发正常
- [ ] 统计数据准确
- [ ] 移动端适配良好

#### 6.2 性能测试
- 页面加载时间 < 2秒
- API响应时间 < 500ms
- 文字比对算法 < 100ms
- 音频加载时间 < 1秒

#### 6.3 用户测试
- 邀请5-10名听障人士测试
- 收集反馈意见
- 优化交互流程
- 调整难度设置

---

## 四、技术栈总结

### 前端
- HTML5 + CSS3
- JavaScript (ES6+)
- Bootstrap 5（UI框架）
- Font Awesome（图标）
- Web Audio API（音频控制）

### 后端
- Python 3.8+
- Flask（Web框架）
- difflib（文字比对）
- pypinyin（拼音处理，可选）

### 已复用的系统功能
- 场景对话生成（DeepSeek API）
- TTS音频生成（阿里云情感TTS）
- 现有的UI组件和样式

---

## 五、开发时间估算

| 模块 | 预估时间 |
|-----|---------|
| 前端UI开发 | 2-3天 |
| 后端API开发 | 2-3天 |
| 文字比对算法 | 2-3天 |
| 激励系统 | 1天 |
| 测试与优化 | 2-3天 |
| **总计** | **9-13天** |

---

## 六、后续扩展方向

1. **AI智能评估**: 使用NLP分析用户的长期进步趋势
2. **多人协作**: 支持家庭成员陪同训练模式
3. **语音识别**: 让用户说出听到的内容（语音转文字）
4. **视频字幕**: 增加视频场景，带字幕辅助
5. **社区功能**: 用户可以分享训练成果和经验
6. **康复计划**: 专业听力师可以制定个性化训练计划

---

## 七、注意事项

1. **隐私保护**: 用户训练数据要加密存储，不得外泄
2. **医疗免责**: 说明本系统是辅助工具，不替代专业医疗建议
3. **无障碍标准**: 严格遵循WCAG 2.1 AA标准
4. **性能优化**: 确保在低端设备上也能流畅运行
5. **错误处理**: 网络断线、API失败等异常情况要友好提示

---

## 八、开发优先级

### P0（核心功能，必须完成）
- 音频播放
- 文字输入
- 基础比对算法
- 结果展示

### P1（重要功能，应该完成）
- 错误标记
- 准确率计算
- 激励反馈
- 进度统计

### P2（增强功能，可以延后）
- 同音字识别
- 形近字识别
- 成就系统
- 个性化设置

### P3（高级功能，有时间再做）
- 数据持久化
- 用户账号系统
- 训练报告导出
- 社区功能

---

## 九、开发起步

### 第一步：修改home.html
在"选择练习模式"区域添加听觉反馈选项。

### 第二步：创建hearing_feedback.html
复制standard_audio.html作为模板，修改为听觉反馈界面。

### 第三步：创建hearing-feedback.js
实现基本的音频播放和文字输入交互。

### 第四步：实现text_comparator.py
先实现基础的字符串比对，后续再优化同音字等高级功能。

### 第五步：添加API路由
在web_interface.py中添加必要的API端点。

### 第六步：测试与迭代
逐步测试每个功能，根据反馈优化体验。

---

**开发建议**: 采用敏捷开发方法，先完成MVP（最小可行产品），再逐步添加高级功能。建议每完成一个功能模块就进行测试，避免最后集中调试。

祝开发顺利！🚀

